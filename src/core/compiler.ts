import type { Session } from './session.js';
import type { RuleFile } from './rules.js';
import { charCount, truncateToChars } from '../utils/chars.js';
import { compressMarkdown, mdSection, mdList } from '../utils/markdown.js';

export interface CompileOptions {
  session: Session | null;
  rules: RuleFile[];
  charBudget: number;
  compress?: boolean; // For tools with tight limits (e.g. Windsurf)
  toolName: string;
}

export interface CompiledOutput {
  content: string;
  resumePrompt: string;
  chars: number;
  rulesIncluded: number;
  rulesTruncated: number;
}

/** Build a session resume prompt — this is what the user pastes into the target tool. */
function buildResumePrompt(session: Session): string {
  const lines: string[] = [];
  lines.push(`Continue the following task. Here is context from a previous session:`);
  lines.push('');
  lines.push(`**Task**: ${session.task}`);

  if (session.branch) {
    lines.push(`**Branch**: ${session.branch}`);
  }
  if (session.headHash) {
    lines.push(`**Last commit**: ${session.headHash}`);
  }
  if (session.decisions.length > 0) {
    lines.push('');
    lines.push('**Key decisions made**:');
    lines.push(mdList(session.decisions));
  }
  if (session.nextSteps.length > 0) {
    lines.push('');
    lines.push('**Next steps**:');
    lines.push(mdList(session.nextSteps));
  }
  if (session.filesChanged.length > 0) {
    lines.push('');
    lines.push('**Files recently changed**:');
    lines.push(mdList(session.filesChanged));
  }
  if (session.diffSummary) {
    lines.push('');
    lines.push(`**Changes**: ${session.diffSummary}`);
  }
  if (session.recentCommits.length > 0) {
    lines.push('');
    lines.push('**Recent commits**:');
    lines.push(mdList(session.recentCommits));
  }

  lines.push('');
  lines.push('Please review the current state of the code and continue from where the previous session left off. Start with the next steps listed above.');

  return lines.join('\n');
}

/** Compile rules + session into output for a specific tool, respecting char budget. */
export function compile(opts: CompileOptions): CompiledOutput {
  const { session, rules, charBudget, compress, toolName } = opts;

  // Build session section (never truncated — always has priority)
  let sessionSection = '';
  if (session) {
    const sessionParts: string[] = [];
    sessionParts.push(`> Session: ${session.id} | ${session.timestamp}`);
    if (session.branch) sessionParts.push(`> Branch: ${session.branch}`);
    if (session.tool) sessionParts.push(`> Previous tool: ${session.tool}`);
    sessionParts.push('');
    sessionParts.push(`**Current task**: ${session.task}`);

    if (session.decisions.length > 0) {
      sessionParts.push('');
      sessionParts.push('**Decisions**:');
      sessionParts.push(mdList(session.decisions));
    }
    if (session.nextSteps.length > 0) {
      sessionParts.push('');
      sessionParts.push('**Next steps**:');
      sessionParts.push(mdList(session.nextSteps));
    }
    if (session.filesChanged.length > 0) {
      sessionParts.push('');
      sessionParts.push('**Files changed**:');
      sessionParts.push(mdList(session.filesChanged));
    }
    if (session.diffSummary) {
      sessionParts.push(`**Changes**: ${session.diffSummary}`);
    }

    sessionSection = mdSection('Session Context (auto-generated by ctx)', sessionParts.join('\n'));
  }

  // Calculate remaining budget after session
  const sessionChars = charCount(sessionSection);
  let remainingBudget = charBudget - sessionChars - 100; // 100 char buffer

  // Add rules in priority order until budget exhausted
  const includedRuleSections: string[] = [];
  let rulesIncluded = 0;
  let rulesTruncated = 0;

  for (const rule of rules) {
    let ruleContent = rule.content;

    if (compress) {
      ruleContent = compressMarkdown(ruleContent);
    }

    const ruleChars = charCount(ruleContent);

    if (ruleChars <= remainingBudget) {
      includedRuleSections.push(ruleContent);
      remainingBudget -= ruleChars;
      rulesIncluded++;
    } else if (remainingBudget > 200) {
      // Partial include
      includedRuleSections.push(truncateToChars(ruleContent, remainingBudget));
      remainingBudget = 0;
      rulesIncluded++;
      rulesTruncated++;
    } else {
      rulesTruncated++;
    }
  }

  // Assemble final output
  const parts: string[] = [];
  if (includedRuleSections.length > 0) {
    parts.push(includedRuleSections.join('\n\n'));
  }
  if (sessionSection) {
    parts.push(sessionSection);
  }

  const content = parts.join('\n\n---\n\n');
  const resumePrompt = session ? buildResumePrompt(session) : '';

  return {
    content,
    resumePrompt,
    chars: charCount(content),
    rulesIncluded,
    rulesTruncated,
  };
}
