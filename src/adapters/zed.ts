import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import type { ToolAdapter } from './types.js';
import { compile } from '../core/compiler.js';

export const zedAdapter: ToolAdapter = {
  name: 'zed',
  displayName: 'Zed',
  charBudget: 100_000,
  compress: false,
  configPaths: ['.rules'],

  async generate({ rules, session, projectRoot }) {
    // Zed uses a single .rules file (first-match from multiple possible formats)
    const result = compile({
      session,
      rules,
      charBudget: this.charBudget,
      compress: false,
      toolName: this.name,
    });

    const header = `# Generated by ai-context-bridge (ctx)\n\n`;
    return {
      [path.join(projectRoot, '.rules')]: header + result.content,
    };
  },

  async importExisting(projectRoot) {
    // Zed checks multiple locations; try the most common ones
    const candidates = ['.rules', '.zed/rules'];
    for (const candidate of candidates) {
      const filePath = path.join(projectRoot, candidate);
      try {
        const stat = await fs.stat(filePath);
        if (stat.isFile()) {
          const content = await fs.readFile(filePath, 'utf-8');
          return content.replace(/^# Generated by ai-context-bridge.*?\n*/s, '').trim() || null;
        }
        if (stat.isDirectory()) {
          const files = await fs.readdir(filePath);
          const parts: string[] = [];
          for (const f of files.sort()) {
            if (f.endsWith('.md')) {
              const c = await fs.readFile(path.join(filePath, f), 'utf-8');
              if (c.trim()) parts.push(c.trim());
            }
          }
          return parts.join('\n\n') || null;
        }
      } catch {
        continue;
      }
    }
    return null;
  },

  async detect() {
    try {
      const { execFile } = await import('node:child_process');
      const { promisify } = await import('node:util');
      await promisify(execFile)('zed', ['--version'], { timeout: 3000 });
      return true;
    } catch {
      return false;
    }
  },
};
