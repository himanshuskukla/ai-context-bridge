import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import * as os from 'node:os';
import { getAllAdapters } from '../../../src/adapters/registry.js';
import type { Session } from '../../../src/core/session.js';
import type { RuleFile } from '../../../src/core/rules.js';

const mockSession: Session = {
  id: 'sess_2026-02-19T10-30-00',
  branch: 'feature/auth',
  timestamp: '2026-02-19T10:30:00Z',
  tool: 'claude-code',
  task: 'Implementing JWT auth middleware',
  decisions: ['RS256 over HS256'],
  nextSteps: ['Add refresh endpoint'],
  filesChanged: ['src/auth.ts'],
  diffSummary: '2 files changed',
  recentCommits: ['abc1234 Add auth'],
  headHash: 'abc1234',
};

const mockRules: RuleFile[] = [
  {
    name: 'project',
    path: '/tmp/rules/01-project.md',
    content: '# Project\n\nNode.js API with Express.',
    priority: 1,
    chars: 35,
  },
];

describe('all adapters generate output', () => {
  let tmpDir: string;

  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ctx-adapter-test-'));
  });

  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });

  const adapters = getAllAdapters();

  for (const adapter of adapters) {
    describe(adapter.name, () => {
      it('generates output with session and rules', async () => {
        const files = await adapter.generate({
          rules: mockRules,
          session: mockSession,
          projectRoot: tmpDir,
        });

        expect(Object.keys(files).length).toBeGreaterThan(0);
        for (const [filePath, content] of Object.entries(files)) {
          expect(filePath).toBeTruthy();
          expect(content.length).toBeGreaterThan(0);
        }
      });

      it('generates output with rules only (no session)', async () => {
        const files = await adapter.generate({
          rules: mockRules,
          session: null,
          projectRoot: tmpDir,
        });

        expect(Object.keys(files).length).toBeGreaterThan(0);
      });

      it('generates output with session only (no rules)', async () => {
        const files = await adapter.generate({
          rules: [],
          session: mockSession,
          projectRoot: tmpDir,
        });

        expect(Object.keys(files).length).toBeGreaterThan(0);
      });

      it('importExisting returns null for empty project', async () => {
        const result = await adapter.importExisting(tmpDir);
        expect(result).toBeNull();
      });
    });
  }
});

describe('adapter-specific formats', () => {
  let tmpDir: string;

  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ctx-format-test-'));
  });

  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });

  it('claude adapter writes CLAUDE.md', async () => {
    const adapter = getAllAdapters().find((a) => a.name === 'claude')!;
    const files = await adapter.generate({ rules: mockRules, session: mockSession, projectRoot: tmpDir });
    const claudeMd = Object.keys(files).find((f) => f.endsWith('CLAUDE.md'));
    expect(claudeMd).toBeTruthy();
    expect(files[claudeMd!]).toContain('Generated by ai-context-bridge');
  });

  it('cursor adapter writes .mdc files with YAML frontmatter', async () => {
    const adapter = getAllAdapters().find((a) => a.name === 'cursor')!;
    const files = await adapter.generate({ rules: mockRules, session: mockSession, projectRoot: tmpDir });

    const mdcFiles = Object.keys(files).filter((f) => f.endsWith('.mdc'));
    expect(mdcFiles.length).toBeGreaterThan(0);

    for (const f of mdcFiles) {
      expect(files[f]).toContain('---');
      expect(files[f]).toContain('alwaysApply');
    }
  });

  it('codex adapter writes AGENTS.md with size limit', async () => {
    const adapter = getAllAdapters().find((a) => a.name === 'codex')!;
    expect(adapter.charBudget).toBe(32_768);
    const files = await adapter.generate({ rules: mockRules, session: mockSession, projectRoot: tmpDir });
    const agentsMd = Object.keys(files).find((f) => f.endsWith('AGENTS.md'));
    expect(agentsMd).toBeTruthy();
  });

  it('windsurf adapter respects 12K total limit', async () => {
    const adapter = getAllAdapters().find((a) => a.name === 'windsurf')!;
    expect(adapter.charBudget).toBe(12_000);
    expect(adapter.compress).toBe(true);
  });

  it('antigravity adapter writes AGENTS.md and .antigravity/ dir', async () => {
    const adapter = getAllAdapters().find((a) => a.name === 'antigravity')!;
    const files = await adapter.generate({ rules: mockRules, session: mockSession, projectRoot: tmpDir });

    const agentsMd = Object.keys(files).find((f) => f.endsWith('AGENTS.md'));
    expect(agentsMd).toBeTruthy();

    const agFiles = Object.keys(files).filter((f) => f.includes('.antigravity'));
    expect(agFiles.length).toBeGreaterThan(0);
  });
});
